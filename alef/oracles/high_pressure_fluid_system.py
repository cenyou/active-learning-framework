# Copyright (c) 2024 Robert Bosch GmbH
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published
# by the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

import numpy as np
import torch
from typing import List, Union
from alef.oracles.base_oracle import StandardOracle
from alef.oracles.base_constrained_oracle import StandardConstrainedOracle
from alef.utils.utils import check1Dlist

from alef.active_learners.amortized_policies.utils.utils import compute_kernel_batch

"""
ref
[1] Christoph Zimmer, Mona Meister, Duy Nguyen-Tuong, 2018, NeurIPS,
Safe Active Learning for Time-Series Modeling with Gaussian Processes

[2] Markus Lange-Hegermann, Christoph Zimmer, 2024, arXiv,
Future Aware Safe Active Learning of Time Varying Systems unp.sing Gaussian Processes
"""

_F_MEAN = 18
_F_STD = 15
_MAX_STEP = 0.3

class HighPressureFluidSystemMain(StandardOracle):
    def __init__(
        self,
        observation_noise: float,
        reduce_dimension: bool=False,
        trajectory_sampler: bool=True,
    ):
        D = 4 if reduce_dimension else 7
        super().__init__(observation_noise, 0.0, 1.0, D)
        self.reduce_dimension = reduce_dimension
        self.trajectory_sampler = trajectory_sampler

    def u_scale(self, u: np.ndarray):
        r"""
        u=(n[t], n[t-1], n[t-2], n[t-3], v[t], v[t-1], v[t-3])
        
        rescale u: [0, 1]^7 --> [1000, 4000]^4 x [0, 60]^3
        """
        assert u.shape[-1] == 7, u.shape
        ti = 0.7 * np.ones(u.shape[:-1])[..., None]
        u_full = np.concatenate([u, ti, ti, ti], axis=-1)

        desire_low_bound = np.array([1000]*4 + [0]*3 + [0]*3)
        desire_up_bound = np.array([4000]*4 + [60]*3 + [1]*3)
        desire_width = desire_up_bound - desire_low_bound
        a, b = self.get_box_bounds()
        return (u_full - a) / (b - a) * desire_width + desire_low_bound

    def f(self, x):
        reshape_low = np.array([
            2253.3056464309,
            2253.3096911602,
            2253.3137973002,
            2253.3179648508,
            38.215389287748,
            38.215412400486,
            38.215460803251,
            0.70942737910475,
            0.70941240606961,
            0.70940475206843,
        ])
        reshape_width = np.array([
            803.10036183397,
            803.0960165043,
            803.09162233565,
            803.08718748759,
            21.683961765866,
            21.68392095213,
            21.683841783813,
            0.53560619117677,
            0.53561824817519,
            0.5356235081677,
        ])
        u = ( self.u_scale( self._interpolate_time_series(x) ) - reshape_low ) / reshape_width
        
        y = 0
        fterm = u[0]* -0.81905999667818 + u[1]* -0.019794720460163 + u[2]* 0.27304841361022 + u[3]* -0.73207404858355 + u[4]* -3.7029124975669 + u[5]* -0.046790795114252 + u[6]* 2.2697846410235 + u[7]* 0.25841712144651 + u[8]* -0.28806898337401 + u[9]* 0.3373995160564
        y=y+ 0.031692908952064 * np.cos(fterm) + 0.068402277004024 * np.sin(fterm)
        fterm = u[0]* 0.33752150846961 + u[1]* 0.22665058943887 + u[2]* 0.0036308221642449 + u[3]* 1.0767220185346 + u[4]* 3.2393608709891 + u[5]* 0.19726557402639 + u[6]* -4.0903224279171 + u[7]* 0.33875023498879 + u[8]* -0.027486115217298 + u[9]* 1.7015867079337
        y=y+ 0.0024380870537466 * np.cos(fterm) + 0.026928849707532 * np.sin(fterm)
        fterm = u[0]* 0.095036088014746 + u[1]* 0.22714724983666 + u[2]* -0.252352037575 + u[3]* -0.18437125084529 + u[4]* -0.96603866774145 + u[5]* -0.025618018257457 + u[6]* -3.2018494389618 + u[7]* 0.33880919065233 + u[8]* 0.15883552468638 + u[9]* 1.7038404546954
        y=y+ 0.03593989016575 * np.cos(fterm) + -0.061165600194329 * np.sin(fterm)
        fterm = u[0]* -0.30750892970496 + u[1]* -0.23891396825039 + u[2]* -0.44176279406099 + u[3]* 0.98871809597707 + u[4]* -5.0299200351586 + u[5]* 0.20496686667996 + u[6]* 1.0113286004103 + u[7]* -0.89964906559001 + u[8]* -1.6251295055196 + u[9]* -1.1594042648733
        y=y+ 0.016985328578553 * np.cos(fterm) + -0.062906411043536 * np.sin(fterm)
        fterm = u[0]* 0.54473897047707 + u[1]* 0.19648071480935 + u[2]* -0.80191433634961 + u[3]* -0.31176920243484 + u[4]* 0.48317144030955 + u[5]* 0.34539198746364 + u[6]* 6.3642693877505 + u[7]* 1.6686848402237 + u[8]* 0.50810563186527 + u[9]* 1.6627586231958
        y=y+ -0.010472575984009 * np.cos(fterm) + -0.034856454748811 * np.sin(fterm)
        fterm = u[0]* -0.90932965603186 + u[1]* 0.0040861403775149 + u[2]* -0.18367251852817 + u[3]* -0.8384362134349 + u[4]* 1.1095932478839 + u[5]* 0.33627852300982 + u[6]* 0.80578324978802 + u[7]* -0.11488487559319 + u[8]* -0.70000840599637 + u[9]* 0.50949820156166
        y=y+ 0.08771158424235 * np.cos(fterm) + -0.056379754715369 * np.sin(fterm)
        fterm = u[0]* -0.34681438881798 + u[1]* 0.043514921077717 + u[2]* 0.12046630595345 + u[3]* -0.11064217792073 + u[4]* 12.409726448748 + u[5]* 0.12883850899569 + u[6]* -13.632000414936 + u[7]* -0.19971464610846 + u[8]* 0.046228428472665 + u[9]* 0.12515304947418
        y=y+ -0.055589202591183 * np.cos(fterm) + -0.17750376299084 * np.sin(fterm)
        fterm = u[0]* 0.5126466445729 + u[1]* 0.12860832423111 + u[2]* -0.21064805610633 + u[3]* -0.50620018378431 + u[4]* 5.236695403519 + u[5]* -0.24441406130094 + u[6]* -4.3045949100653 + u[7]* 0.61624905468049 + u[8]* 2.1138749574221 + u[9]* -0.32086813690263
        y=y+ -0.018944359148021 * np.cos(fterm) + -0.024568581080264 * np.sin(fterm)
        fterm = u[0]* -0.90786223620836 + u[1]* 0.25228903489171 + u[2]* -0.53485124507674 + u[3]* -1.8522537551352 + u[4]* 1.5666089210993 + u[5]* -0.24489915142453 + u[6]* -3.8189488996167 + u[7]* 0.54909352731943 + u[8]* 0.9272179256372 + u[9]* 1.8009119972273
        y=y+ 0.018516761200688 * np.cos(fterm) + 0.031299127609342 * np.sin(fterm)
        fterm = u[0]* 0.84723127607948 + u[1]* 0.050280388584138 + u[2]* 0.16693223406574 + u[3]* -0.60517770461978 + u[4]* -0.79132263098257 + u[5]* 0.084043948902495 + u[6]* 0.55685759728236 + u[7]* 0.34486591580833 + u[8]* 1.4416809309088 + u[9]* -0.53320421692272
        y=y+ -3.4990059374596 * np.cos(fterm) + 0.68253876032375 * np.sin(fterm)
        fterm = u[0]* -0.19681773285744 + u[1]* 0.058254908022228 + u[2]* -0.42707928242563 + u[3]* 0.10819564756371 + u[4]* 0.04704308876312 + u[5]* 0.086127140665846 + u[6]* -0.024740149959336 + u[7]* 0.93632616781613 + u[8]* -0.035165710684237 + u[9]* 0.6569247940928
        y=y+ -0.17115042174198 * np.cos(fterm) + -0.28252973516886 * np.sin(fterm)
        fterm = u[0]* -0.0019037079266071 + u[1]* 0.18580405652159 + u[2]* 0.25080372029813 + u[3]* -0.38404653550615 + u[4]* -2.6288831462221 + u[5]* -0.2747417045966 + u[6]* 2.1320451793595 + u[7]* -1.045444967573 + u[8]* -0.79282650529856 + u[9]* 0.031010778657905
        y=y+ 0.059811477926127 * np.cos(fterm) + 0.15289618520218 * np.sin(fterm)
        fterm = u[0]* 0.19814051576479 + u[1]* 0.12473129275844 + u[2]* 0.18289812163033 + u[3]* -0.040240761962992 + u[4]* -3.3405395082573 + u[5]* 0.11291153891139 + u[6]* -2.1744195857812 + u[7]* 0.16544111454727 + u[8]* 1.0327303718767 + u[9]* 1.5923228862532
        y=y+ -0.010118619494568 * np.cos(fterm) + -0.0074420349679962 * np.sin(fterm)
        fterm = u[0]* -0.11678811433869 + u[1]* 0.40545196498035 + u[2]* -0.32209724522756 + u[3]* -1.2191020365812 + u[4]* -7.0124770086352 + u[5]* 0.03675927486414 + u[6]* 5.5603653868838 + u[7]* 0.37164881797739 + u[8]* -1.5113345858393 + u[9]* 0.66274581255803
        y=y+ 0.086117006049066 * np.cos(fterm) + -0.04913820310423 * np.sin(fterm)
        fterm = u[0]* -0.32593022105524 + u[1]* 0.079875980525919 + u[2]* 0.099870348032266 + u[3]* -0.67291405487035 + u[4]* -0.37666675860489 + u[5]* 0.20938689455095 + u[6]* 9.1755464525272 + u[7]* 2.2122935682262 + u[8]* 0.16197494065924 + u[9]* -0.018643916230819
        y=y+ 0.0022606327417702 * np.cos(fterm) + 0.023805375609675 * np.sin(fterm)
        fterm = u[0]* 0.84460551424592 + u[1]* -0.33094975587693 + u[2]* -0.010826144353245 + u[3]* 0.27948211496192 + u[4]* 0.17197033871996 + u[5]* -0.097541935974101 + u[6]* -0.30621259089848 + u[7]* -0.35493284958512 + u[8]* -0.1698519033907 + u[9]* 0.70620227752212
        y=y+ -0.053636933766471 * np.cos(fterm) + 0.40565361766112 * np.sin(fterm)
        fterm = u[0]* 0.17876901517902 + u[1]* 0.070199320612956 + u[2]* 0.14344749513824 + u[3]* -0.46963022472564 + u[4]* 6.3748083838038 + u[5]* 0.11207349357088 + u[6]* -4.1269050756988 + u[7]* 0.63174216577317 + u[8]* -0.10275316910193 + u[9]* -0.1838974495232
        y=y+ 0.0091583716548813 * np.cos(fterm) + 0.064570155156537 * np.sin(fterm)
        fterm = u[0]* 0.13173338939796 + u[1]* -0.28009532216854 + u[2]* 0.092772965987904 + u[3]* -1.5059798078413 + u[4]* -2.1352598181993 + u[5]* 0.10509416454745 + u[6]* -0.53606803801543 + u[7]* -0.18990485591095 + u[8]* 0.77387432217994 + u[9]* -0.23630436139784
        y=y+ 0.024383694318798 * np.cos(fterm) + -0.073684695482718 * np.sin(fterm)
        fterm = u[0]* 0.8804356524727 + u[1]* -0.14927153177112 + u[2]* -0.057756555652038 + u[3]* 1.0075676397375 + u[4]* -2.4857722942484 + u[5]* 0.15649829748824 + u[6]* 2.5030070853474 + u[7]* 1.3304923152072 + u[8]* -0.12114833963005 + u[9]* -0.31746502804656
        y=y+ 0.084057404036463 * np.cos(fterm) + 0.080342220979079 * np.sin(fterm)
        fterm = u[0]* -0.45892995128513 + u[1]* -0.087896961270462 + u[2]* -0.28713116616515 + u[3]* -0.37405851179436 + u[4]* -1.6627204298282 + u[5]* -0.10621951132626 + u[6]* -0.19502828709312 + u[7]* -0.088310579759066 + u[8]* -1.2096077751772 + u[9]* 1.2425887574684
        y=y+ -0.10632114607956 * np.cos(fterm) + 0.028028588569602 * np.sin(fterm)
        fterm = u[0]* 0.31768351305308 + u[1]* 0.060754198486302 + u[2]* 0.013545521015915 + u[3]* -0.7766269370097 + u[4]* -0.61787733817351 + u[5]* 0.10467080505564 + u[6]* 1.2082028035424 + u[7]* -0.37850368236208 + u[8]* 0.4094129670629 + u[9]* -0.53695066829666
        y=y+ 0.43252746651226 * np.cos(fterm) + 0.016552122636672 * np.sin(fterm)
        fterm = u[0]* 0.25758237719377 + u[1]* -0.25356195272768 + u[2]* -0.6786377277186 + u[3]* -1.0718851905902 + u[4]* 0.83322277658286 + u[5]* -0.30758875879175 + u[6]* -0.63470396094589 + u[7]* 1.2643960155815 + u[8]* -1.0684094036204 + u[9]* 0.45116263179746
        y=y+ -0.0074853421942671 * np.cos(fterm) + -0.068405137339272 * np.sin(fterm)
        fterm = u[0]* -0.26216784296152 + u[1]* -0.41730575070274 + u[2]* 0.015155508164056 + u[3]* -0.24359833967796 + u[4]* -0.12071617316971 + u[5]* -0.16570655132297 + u[6]* -1.7909030170594 + u[7]* -0.40755201770749 + u[8]* -1.0229730332706 + u[9]* -0.68446950944111
        y=y+ -0.049061333210103 * np.cos(fterm) + -0.18136933353012 * np.sin(fterm)
        fterm = u[0]* -0.17677316792512 + u[1]* -0.025469605233643 + u[2]* -0.1910114792626 + u[3]* 0.92943887248222 + u[4]* 0.35620276653333 + u[5]* -0.23245634977757 + u[6]* -1.8916035502678 + u[7]* 0.74548920174067 + u[8]* -0.40759478019872 + u[9]* -1.1381431030634
        y=y+ -0.016909584800276 * np.cos(fterm) + 0.10722899471275 * np.sin(fterm)
        fterm = u[0]* -0.43977970353579 + u[1]* -0.15622561448743 + u[2]* 0.64811378783201 + u[3]* -0.14286146577477 + u[4]* 0.66032866159992 + u[5]* -0.29121017753958 + u[6]* -2.2201938034659 + u[7]* 0.22837161242404 + u[8]* 1.0452005681998 + u[9]* 2.7703274410098
        y=y+ 0.047939907064817 * np.cos(fterm) + 0.058542345464866 * np.sin(fterm)
        fterm = u[0]* 0.80878100421884 + u[1]* -0.1832152414184 + u[2]* 0.79808714115796 + u[3]* 0.32102197337873 + u[4]* 0.30887569585679 + u[5]* -0.019982765911454 + u[6]* -0.048597787228745 + u[7]* 0.83984658398251 + u[8]* 0.095459155459479 + u[9]* -1.5308996912961
        y=y+ -0.027583794700889 * np.cos(fterm) + -0.015807980686177 * np.sin(fterm)
        fterm = u[0]* 0.75135425825118 + u[1]* 0.32907884453582 + u[2]* 0.083193143066692 + u[3]* 0.63183684850071 + u[4]* 1.453284313977 + u[5]* -0.043615950135482 + u[6]* -0.91140517823509 + u[7]* 0.38237529105443 + u[8]* 0.32872090921479 + u[9]* -0.12651777143292
        y=y+ -0.051786986817071 * np.cos(fterm) + -0.082560931826909 * np.sin(fterm)
        fterm = u[0]* 0.011668877891523 + u[1]* -0.041078264870397 + u[2]* 0.62851420706784 + u[3]* -0.6894866112561 + u[4]* 4.157527054699 + u[5]* -0.16842535817262 + u[6]* -4.8078863734826 + u[7]* -0.34741726477873 + u[8]* -0.65921610281342 + u[9]* 0.86790778494934
        y=y+ -0.084121464323058 * np.cos(fterm) + -0.11677906289896 * np.sin(fterm)
        fterm = u[0]* -0.46558466749701 + u[1]* -0.18491041977008 + u[2]* -0.17118747295036 + u[3]* 0.49679229476403 + u[4]* 2.5697896940838 + u[5]* -0.066126179601844 + u[6]* -0.82627814981748 + u[7]* 0.31777498840923 + u[8]* 0.84316776324651 + u[9]* 0.95729808447415
        y=y+ -0.11881647098682 * np.cos(fterm) + -0.0028600422974877 * np.sin(fterm)
        fterm = u[0]* 1.6037567163433 + u[1]* 0.00053758943283798 + u[2]* -0.32091470765556 + u[3]* 0.97084640098594 + u[4]* -2.9941574018056 + u[5]* -0.46712568401221 + u[6]* -1.8116137105656 + u[7]* 0.054856490528935 + u[8]* 0.48579759317903 + u[9]* -0.24774637606093
        y=y+ 0.015369878517688 * np.cos(fterm) + -0.0014170875474372 * np.sin(fterm)
        fterm = u[0]* -0.23987681510562 + u[1]* -0.25593431278915 + u[2]* 0.0019787299505214 + u[3]* -0.32541985863337 + u[4]* -2.9560371696221 + u[5]* -0.34906715633717 + u[6]* -3.7363276022986 + u[7]* 0.042673616217396 + u[8]* -0.58697902541369 + u[9]* -0.7759755094146
        y=y+ -0.015786717443258 * np.cos(fterm) + 0.024975094967218 * np.sin(fterm)
        fterm = u[0]* -0.22583019727704 + u[1]* -0.077395441495797 + u[2]* -0.90070097121186 + u[3]* -1.3515781775198 + u[4]* 0.96817936231753 + u[5]* 0.016511460088508 + u[6]* -0.80685627363305 + u[7]* -1.4141167726755 + u[8]* -0.14414186371363 + u[9]* -1.1413811739829
        y=y+ 0.03439862320363 * np.cos(fterm) + -0.046598080481382 * np.sin(fterm)
        fterm = u[0]* 0.36159338585778 + u[1]* 0.024673785898007 + u[2]* -0.49530279421355 + u[3]* -0.53200062724239 + u[4]* 4.7428418297513 + u[5]* -0.13520534322518 + u[6]* 2.7194971849481 + u[7]* -0.34157058625228 + u[8]* -0.14560613302904 + u[9]* -1.3550265164725
        y=y+ -0.011518035023694 * np.cos(fterm) + -0.053273940541563 * np.sin(fterm)
        fterm = u[0]* 0.43925709965552 + u[1]* 0.045770084803915 + u[2]* -0.28623521155044 + u[3]* -0.36182542785672 + u[4]* 1.8435442636642 + u[5]* 0.13764671627122 + u[6]* -1.7369880310385 + u[7]* -0.67718098088346 + u[8]* 0.96181819307071 + u[9]* 0.90188716127572
        y=y+ 0.23288826713576 * np.cos(fterm) + -0.15672951801364 * np.sin(fterm)
        fterm = u[0]* 0.064598397316458 + u[1]* -0.096604519115184 + u[2]* -0.39600241189883 + u[3]* 0.82081540685491 + u[4]* 3.7967918536811 + u[5]* -0.32479462323413 + u[6]* -6.8163120661345 + u[7]* -0.66256830456833 + u[8]* -0.72268349097057 + u[9]* -0.60484037951159
        y=y+ -0.0046388898142893 * np.cos(fterm) + -0.079687036388495 * np.sin(fterm)
        fterm = u[0]* 0.37445329094819 + u[1]* -0.363050810254 + u[2]* -0.85538049193332 + u[3]* 0.52346497545624 + u[4]* 4.1858898231664 + u[5]* -0.15817295606714 + u[6]* -6.0893988831619 + u[7]* 0.45630187667385 + u[8]* -0.074689397657911 + u[9]* -0.44773066097934
        y=y+ 0.044154822592607 * np.cos(fterm) + -0.13794930346985 * np.sin(fterm)
        fterm = u[0]* -0.059317512967557 + u[1]* -0.11022537799313 + u[2]* 0.31400317452795 + u[3]* -0.75274374233922 + u[4]* 1.0373155190017 + u[5]* 0.30714349808628 + u[6]* -3.5554839662073 + u[7]* -1.2221273756119 + u[8]* 0.50864317961329 + u[9]* -0.84515229970508
        y=y+ -0.060686607415732 * np.cos(fterm) + -0.088015554200766 * np.sin(fterm)
        fterm = u[0]* -0.29244085118027 + u[1]* -0.019183333270204 + u[2]* -0.077483622043874 + u[3]* -1.0736630167229 + u[4]* 3.04419549621 + u[5]* -0.11645011564443 + u[6]* -3.7448151043279 + u[7]* -1.0090715552592 + u[8]* -2.0064460721785 + u[9]* -1.0847868318571
        y=y+ 0.064300654108802 * np.cos(fterm) + 0.025756630419533 * np.sin(fterm)
        fterm = u[0]* 0.20500545105685 + u[1]* 0.042721643850222 + u[2]* -0.28239556672529 + u[3]* 0.029533614880545 + u[4]* -0.50155646564908 + u[5]* -0.17524499316815 + u[6]* 5.6667285838448 + u[7]* 0.24892316862687 + u[8]* -0.57378696284797 + u[9]* 1.6207438609699
        y=y+ 0.053651372132957 * np.cos(fterm) + -0.019255348978032 * np.sin(fterm)
        fterm = u[0]* 0.80835434001989 + u[1]* 0.033730865058327 + u[2]* -0.36192000465059 + u[3]* 0.068972098703966 + u[4]* 0.39392332382431 + u[5]* 0.02545045216391 + u[6]* 1.8776375750048 + u[7]* 0.84579939266458 + u[8]* -0.83045785788514 + u[9]* -0.48607999231105
        y=y+ -0.11951754174837 * np.cos(fterm) + -0.015213137309564 * np.sin(fterm)
        fterm = u[0]* 0.61621830446052 + u[1]* -0.20213981234134 + u[2]* -0.68587765032013 + u[3]* -0.16699261687744 + u[4]* 0.57880370456389 + u[5]* -0.097281575761222 + u[6]* -0.10123488308088 + u[7]* -0.65262972664406 + u[8]* -0.77807867134149 + u[9]* 0.43874433329463
        y=y+ 0.67897256508403 * np.cos(fterm) + 0.45842360791261 * np.sin(fterm)
        fterm = u[0]* 0.69715873877587 + u[1]* -0.066252785620862 + u[2]* 0.27855742844366 + u[3]* -0.72016847115053 + u[4]* 9.004546581274 + u[5]* -0.023021945093869 + u[6]* -8.0358050609837 + u[7]* 0.070269407451441 + u[8]* -0.17145826222352 + u[9]* 0.23371762786191
        y=y+ -0.11558159654724 * np.cos(fterm) + 0.1280981152627 * np.sin(fterm)
        fterm = u[0]* 0.061123532802879 + u[1]* 0.31117935807833 + u[2]* -0.042175847334849 + u[3]* 1.0643277928174 + u[4]* 3.571742118105 + u[5]* 0.060501661631117 + u[6]* -3.1048698462113 + u[7]* 0.40682378280127 + u[8]* 0.83377672510518 + u[9]* -1.0219143195115
        y=y+ 0.12748200297507 * np.cos(fterm) + 0.049135256473724 * np.sin(fterm)
        fterm = u[0]* -0.44209301626502 + u[1]* 0.054516649430299 + u[2]* -0.71758192434574 + u[3]* 0.69285987658271 + u[4]* -1.9573420448319 + u[5]* 0.37990622043178 + u[6]* -2.4086154903417 + u[7]* -0.31509319788408 + u[8]* 0.91215670154238 + u[9]* -0.40144522153246
        y=y+ -0.034712965813719 * np.cos(fterm) + 0.046483858820691 * np.sin(fterm)
        fterm = u[0]* -0.8115922537416 + u[1]* 0.015683113181554 + u[2]* 0.041448036256392 + u[3]* -0.58974637492163 + u[4]* 1.0023351224226 + u[5]* -0.10293406857145 + u[6]* -0.81923159078529 + u[7]* -1.0525319967428 + u[8]* -0.4659667165728 + u[9]* -1.2676270486531
        y=y+ -0.068291348633799 * np.cos(fterm) + 0.077118109718707 * np.sin(fterm)
        fterm = u[0]* -0.6870714685788 + u[1]* -0.16954182644662 + u[2]* -0.15518803300695 + u[3]* -0.10882766625271 + u[4]* 0.95457462902051 + u[5]* -0.23744205001861 + u[6]* -0.36616055202298 + u[7]* 0.3541862497669 + u[8]* 0.057071813041939 + u[9]* -0.18828258229724
        y=y+ -0.12766999274979 * np.cos(fterm) + 0.37594579379313 * np.sin(fterm)
        fterm = u[0]* -1.2233133350886 + u[1]* 0.2818169111056 + u[2]* 0.68768773694539 + u[3]* 0.30228449129992 + u[4]* 2.9491625036004 + u[5]* 0.021740132213148 + u[6]* -0.78981562725561 + u[7]* -1.1797429142248 + u[8]* -1.3043266779761 + u[9]* 0.27035547879731
        y=y+ -0.0043180756877553 * np.cos(fterm) + -0.039611362195905 * np.sin(fterm)
        fterm = u[0]* 0.40396480218111 + u[1]* 0.036748442602898 + u[2]* -0.61937693804835 + u[3]* 0.27402193978315 + u[4]* -1.7842147913316 + u[5]* 0.18969225643528 + u[6]* 2.5576465009336 + u[7]* -0.15063584259683 + u[8]* -2.0517360876039 + u[9]* 1.775081107002
        y=y+ 0.020784074404751 * np.cos(fterm) + -0.10852650573083 * np.sin(fterm)
        fterm = u[0]* 0.4028289598915 + u[1]* -0.073175411728252 + u[2]* -0.53458882076387 + u[3]* 0.29728563312547 + u[4]* 0.62698706643598 + u[5]* -0.1625781539619 + u[6]* -0.17510801055693 + u[7]* 0.51199125506705 + u[8]* 0.54716019643085 + u[9]* -1.3632242063645
        y=y+ 0.3427433447271 * np.cos(fterm) + 0.29556700908644 * np.sin(fterm)
        fterm = u[0]* 0.24719249279029 + u[1]* 0.53888175734965 + u[2]* 0.82640950274578 + u[3]* 0.77593890535894 + u[4]* -1.4871335430835 + u[5]* 0.063923384775276 + u[6]* -1.4823186298831 + u[7]* 0.45828293578681 + u[8]* 0.61353634209822 + u[9]* -0.030632200465192
        y=y+ -0.079967881764442 * np.cos(fterm) + -0.039971495234953 * np.sin(fterm)
        fterm = u[0]* 0.012422692796249 + u[1]* 0.28588048766519 + u[2]* -0.14705908711552 + u[3]* 1.0347973283625 + u[4]* -3.0289662397224 + u[5]* -0.21657919993359 + u[6]* -3.0576659047943 + u[7]* -0.52152583763585 + u[8]* 0.60779451482956 + u[9]* 1.5724457442509
        y=y+ 0.016197643889979 * np.cos(fterm) + -0.02311509558311 * np.sin(fterm)
        fterm = u[0]* -0.61141511700201 + u[1]* 0.13290626223625 + u[2]* 0.095219977256908 + u[3]* -0.14657309929045 + u[4]* -4.1277646553299 + u[5]* 0.11068453286229 + u[6]* 2.8747029628855 + u[7]* -0.54215387567982 + u[8]* -0.45116706073738 + u[9]* 1.7741546185254
        y=y+ -0.040138849880116 * np.cos(fterm) + 0.074962524125227 * np.sin(fterm)
        fterm = u[0]* -0.39107551291792 + u[1]* 0.12274660608723 + u[2]* -0.60178277343316 + u[3]* 0.6602659147272 + u[4]* 1.5156204231173 + u[5]* -0.010184729966952 + u[6]* -1.8673434534205 + u[7]* 0.28893976397337 + u[8]* -0.77075294468846 + u[9]* -0.19924946508226
        y=y+ -0.20336766861947 * np.cos(fterm) + 0.33595325035672 * np.sin(fterm)
        fterm = u[0]* 0.013413509884823 + u[1]* 0.040304867605146 + u[2]* 0.79704844922216 + u[3]* 0.83154542377705 + u[4]* 0.14268370176646 + u[5]* 0.11559116505276 + u[6]* 1.9640395532104 + u[7]* 1.38891577714 + u[8]* 0.34927172570989 + u[9]* 0.46568732037223
        y=y+ 0.069177423378979 * np.cos(fterm) + -0.061434451343931 * np.sin(fterm)
        fterm = u[0]* 0.23627975818342 + u[1]* 0.026179118145544 + u[2]* -0.43496460935533 + u[3]* -0.2957285364787 + u[4]* 0.8359053206001 + u[5]* -0.13529122795089 + u[6]* -0.59076809851459 + u[7]* -0.31742811991633 + u[8]* -1.5477420509238 + u[9]* 0.5490837993564
        y=y+ 3.0717135720378 * np.cos(fterm) + 0.42595342511833 * np.sin(fterm)
        fterm = u[0]* -0.33577157755192 + u[1]* -0.1890541145897 + u[2]* -0.044115794840124 + u[3]* 0.25836953839076 + u[4]* 2.6503599150371 + u[5]* -0.18131623386889 + u[6]* 3.0719027772353 + u[7]* 0.24558608715437 + u[8]* 0.90474113435491 + u[9]* -1.4636261033049
        y=y+ 0.025265155820038 * np.cos(fterm) + 0.0082123072262535 * np.sin(fterm)
        fterm = u[0]* 0.25459319593585 + u[1]* -0.388183457583 + u[2]* -0.57560753449426 + u[3]* 0.076838701081425 + u[4]* 2.100720398664 + u[5]* -0.099082438310629 + u[6]* 0.58133229208003 + u[7]* -0.016242740362897 + u[8]* 1.1969145539546 + u[9]* -2.6154766617621
        y=y+ -0.055206719748503 * np.cos(fterm) + -0.037797398860482 * np.sin(fterm)
        fterm = u[0]* -0.25188182923633 + u[1]* -0.18007007905242 + u[2]* -0.36475152983176 + u[3]* -0.087203328561246 + u[4]* 0.48076813999135 + u[5]* -0.17766311279376 + u[6]* 1.688345899356 + u[7]* -0.096706131852119 + u[8]* -0.14158435712413 + u[9]* -0.29487491948705
        y=y+ -0.03430882993683 * np.cos(fterm) + 0.15894107821953 * np.sin(fterm)
        fterm = u[0]* 0.40576220232117 + u[1]* 0.080362129537167 + u[2]* 0.27772777647952 + u[3]* 0.4482599293108 + u[4]* 2.2325772254501 + u[5]* -0.13769785324422 + u[6]* -3.8766768620419 + u[7]* -0.041222843424161 + u[8]* -0.27890131495352 + u[9]* 0.19552807997064
        y=y+ 0.040853423247748 * np.cos(fterm) + 0.026081877370598 * np.sin(fterm)
        fterm = u[0]* 1.0486970586256 + u[1]* 0.58480202365134 + u[2]* 0.19761511597858 + u[3]* -0.48318636514403 + u[4]* 2.1692622059488 + u[5]* 0.104324832837 + u[6]* 3.0013041490242 + u[7]* -0.0013034081387521 + u[8]* -0.2755002819141 + u[9]* -1.5566669526027
        y=y+ -0.0013882997029764 * np.cos(fterm) + -0.015511807781405 * np.sin(fterm)
        fterm = u[0]* -0.31386081002059 + u[1]* 0.1293020499412 + u[2]* 0.11529795460325 + u[3]* -0.24822392526695 + u[4]* -3.3160561798488 + u[5]* 0.44706491421305 + u[6]* -1.8294190352312 + u[7]* -0.053453033705414 + u[8]* -0.49280245287429 + u[9]* 0.19694055980245
        y=y+ -0.060980637003501 * np.cos(fterm) + 0.14055568329736 * np.sin(fterm)
        fterm = u[0]* 0.25994500139995 + u[1]* -0.078939580699695 + u[2]* -0.01494390554366 + u[3]* 0.47595755604079 + u[4]* 0.81351882927992 + u[5]* 0.071500271326471 + u[6]* -0.55798198062438 + u[7]* -1.1381046703675 + u[8]* -1.0426145502673 + u[9]* -0.59339919002787
        y=y+ -0.089029068082855 * np.cos(fterm) + 0.004576124468916 * np.sin(fterm)
        fterm = u[0]* -0.73157058341543 + u[1]* 0.3700308214291 + u[2]* 0.33500770801749 + u[3]* 0.018024187931452 + u[4]* 1.2205331546415 + u[5]* -0.18169028160815 + u[6]* -4.4857174787933 + u[7]* -0.75684286937228 + u[8]* 0.34485953827102 + u[9]* 0.085304783163633
        y=y+ 0.085377058203667 * np.cos(fterm) + 0.031528621633092 * np.sin(fterm)
        fterm = u[0]* -0.15242786643233 + u[1]* 0.0025867522449353 + u[2]* 0.44500713480761 + u[3]* -0.79318481758384 + u[4]* -1.7823408419956 + u[5]* 0.20269196179305 + u[6]* -4.8894343557039 + u[7]* 0.65510375537264 + u[8]* 0.80417195998693 + u[9]* 0.8577866112518
        y=y+ 0.014358954022024 * np.cos(fterm) + 0.029772391811455 * np.sin(fterm)
        fterm = u[0]* -0.063928130376962 + u[1]* -0.0046039198715692 + u[2]* 0.67747500772939 + u[3]* 0.43190885676114 + u[4]* 0.91902505388909 + u[5]* 0.20261839326194 + u[6]* -2.7174511895402 + u[7]* 0.62376436068261 + u[8]* -1.5480884497021 + u[9]* -1.9334713339308
        y=y+ 0.00092096943883582 * np.cos(fterm) + 0.051218065835908 * np.sin(fterm)
        fterm = u[0]* 0.17447009697427 + u[1]* 0.16264768985038 + u[2]* 0.6126307557983 + u[3]* 0.38821088563286 + u[4]* 1.6460486822933 + u[5]* 0.11904629785382 + u[6]* 4.4526474812372 + u[7]* -1.2874473677698 + u[8]* -0.53353562411878 + u[9]* -0.94954520859861
        y=y+ 0.0041032472616334 * np.cos(fterm) + 0.026064196886314 * np.sin(fterm)
        fterm = u[0]* -0.11381273673559 + u[1]* -0.11309789711385 + u[2]* 0.40577937398995 + u[3]* -0.60012174166095 + u[4]* -3.0754731732655 + u[5]* 0.00059941618785972 + u[6]* -2.255890362792 + u[7]* -0.22475924599207 + u[8]* -0.37080176484437 + u[9]* 0.24450911270488
        y=y+ -0.037312990607426 * np.cos(fterm) + -0.13923789452907 * np.sin(fterm)
        fterm = u[0]* 0.73311134921818 + u[1]* 0.30884254753799 + u[2]* 0.19912824792272 + u[3]* 0.47867765355674 + u[4]* -9.9376866939528 + u[5]* -0.26458859522512 + u[6]* -3.4585407939256 + u[7]* -0.64018780183579 + u[8]* 0.87941998857369 + u[9]* -1.1364026640412
        y=y+ -0.0080843906837836 * np.cos(fterm) + 0.0085226826746696 * np.sin(fterm)
        fterm = u[0]* 0.77106503579505 + u[1]* -0.090102588331579 + u[2]* 0.18881987091193 + u[3]* 0.74168758914324 + u[4]* -4.6126095589984 + u[5]* 0.12580729209152 + u[6]* 0.61363369687333 + u[7]* -0.24884677386098 + u[8]* -0.65843414165576 + u[9]* -2.2102908294502
        y=y+ 0.015989293279952 * np.cos(fterm) + -0.012531332785732 * np.sin(fterm)
        fterm = u[0]* -0.32634568173872 + u[1]* 0.041571313604241 + u[2]* -0.76226551693684 + u[3]* -0.059375361674349 + u[4]* 3.5742752522233 + u[5]* -0.14970045182107 + u[6]* 0.97835294350369 + u[7]* 0.10905628141524 + u[8]* 0.23364474393908 + u[9]* 0.94102444425663
        y=y+ -0.0064939405986199 * np.cos(fterm) + -0.046195210898848 * np.sin(fterm)
        fterm = u[0]* -0.89739581078345 + u[1]* 0.14111364565511 + u[2]* -0.29049561000264 + u[3]* -0.23732677579395 + u[4]* 0.73573877375747 + u[5]* 0.20717826702202 + u[6]* 1.0510327826059 + u[7]* -1.89027936533 + u[8]* 0.98497827877588 + u[9]* -1.361749264021
        y=y+ 0.040109282095949 * np.cos(fterm) + 0.034693150867751 * np.sin(fterm)
        fterm = u[0]* -0.5826919870097 + u[1]* 0.021842676690041 + u[2]* -0.48892035358605 + u[3]* 0.63536266921571 + u[4]* 4.1600250518594 + u[5]* 0.25507730526919 + u[6]* -2.2829257029429 + u[7]* -1.1224303280368 + u[8]* -0.39902675894711 + u[9]* -1.0826638376451
        y=y+ -0.039981510039405 * np.cos(fterm) + -0.017204146455158 * np.sin(fterm)
        fterm = u[0]* 0.030230176956927 + u[1]* -0.296730661779 + u[2]* 0.011517022440393 + u[3]* 0.055187508805417 + u[4]* -1.9566404265983 + u[5]* 0.077188842592816 + u[6]* 2.068856413021 + u[7]* 1.1795985503023 + u[8]* 0.68331050991756 + u[9]* 2.7860010644792
        y=y+ -0.058584871580974 * np.cos(fterm) + -0.017393943656854 * np.sin(fterm)
        fterm = u[0]* 0.31822709333089 + u[1]* -0.014271464298613 + u[2]* 0.70535523626635 + u[3]* 0.2742032039563 + u[4]* 1.4570613279171 + u[5]* 0.11385902494481 + u[6]* -0.99207722105192 + u[7]* -0.65912129020136 + u[8]* 1.3836058945175 + u[9]* 1.7607664501676
        y=y+ 0.091013521410747 * np.cos(fterm) + -0.016028891176556 * np.sin(fterm)
        fterm = u[0]* -0.86802514838381 + u[1]* -0.3354593208007 + u[2]* -0.41552143253572 + u[3]* 0.20824900545061 + u[4]* -3.8462053401617 + u[5]* 0.026213222748612 + u[6]* -0.17350927185547 + u[7]* 1.409010967085 + u[8]* 0.89354106903164 + u[9]* 1.2971490987342
        y=y+ -0.019081474586905 * np.cos(fterm) + -0.022425834954556 * np.sin(fterm)
        fterm = u[0]* -0.25793449504941 + u[1]* 0.71037864534253 + u[2]* 0.7267138173557 + u[3]* 1.1998813791212 + u[4]* 3.5053884111367 + u[5]* 0.14584112687278 + u[6]* -2.9387848525964 + u[7]* -0.23244674942071 + u[8]* -1.4816666350978 + u[9]* -0.16874633991965
        y=y+ 0.0095682147175978 * np.cos(fterm) + 0.011403276459972 * np.sin(fterm)
        fterm = u[0]* 0.74100143992648 + u[1]* 0.19894178799665 + u[2]* 0.018332770745976 + u[3]* -0.63276674310163 + u[4]* 2.3105586916758 + u[5]* -0.26716792155061 + u[6]* -2.0023305883282 + u[7]* -0.044046540936418 + u[8]* -0.61801259397661 + u[9]* 0.019247008483582
        y=y+ 0.38594893233202 * np.cos(fterm) + 0.13289299422207 * np.sin(fterm)
        fterm = u[0]* -0.21210027099482 + u[1]* 0.23213437753485 + u[2]* 0.32295060672409 + u[3]* 0.37943237695541 + u[4]* -0.098498100939365 + u[5]* -0.06472187290408 + u[6]* -3.7431422682593 + u[7]* -1.4681947230847 + u[8]* 1.5739407894498 + u[9]* -1.3693647285006
        y=y+ -0.0057533003864996 * np.cos(fterm) + -0.053911558965515 * np.sin(fterm)
        fterm = u[0]* -0.3294642883148 + u[1]* -0.08221291323503 + u[2]* 0.21569623682358 + u[3]* -0.74270301815544 + u[4]* 0.19744550085899 + u[5]* -0.26914920486125 + u[6]* 1.3797277456814 + u[7]* -0.35061993574076 + u[8]* 0.65226836204528 + u[9]* 0.9871671568106
        y=y+ 0.063113280244711 * np.cos(fterm) + 0.094482739846245 * np.sin(fterm)
        fterm = u[0]* -0.0024102825865738 + u[1]* -0.31836713541293 + u[2]* -0.034270346647274 + u[3]* 0.52430545902216 + u[4]* -1.6725636427132 + u[5]* 0.05855420600357 + u[6]* -0.33719717795816 + u[7]* 0.53398251160395 + u[8]* 0.96179910045751 + u[9]* 0.762603622521
        y=y+ 0.15792444770157 * np.cos(fterm) + -0.022371143214056 * np.sin(fterm)
        fterm = u[0]* 0.75413364712181 + u[1]* -0.45647784695528 + u[2]* 1.0265422834213 + u[3]* -0.68153086045924 + u[4]* -1.2594124711685 + u[5]* -0.13599007237109 + u[6]* -1.7556455791042 + u[7]* -0.19956850595755 + u[8]* -0.95035708496566 + u[9]* -0.73805599735145
        y=y+ -0.081925089440202 * np.cos(fterm) + 0.017141090759093 * np.sin(fterm)
        fterm = u[0]* -0.45156317334975 + u[1]* -0.32357922653324 + u[2]* 0.7760892474274 + u[3]* 0.43832634996747 + u[4]* 3.9279769394259 + u[5]* -0.11136671902838 + u[6]* -0.7575971715878 + u[7]* 0.37561305045973 + u[8]* 0.17832902806532 + u[9]* 0.24555793334044
        y=y+ 0.13738424777592 * np.cos(fterm) + 0.053265857701089 * np.sin(fterm)
        fterm = u[0]* -0.6906030480701 + u[1]* 0.41163068958208 + u[2]* -0.4027333293875 + u[3]* 0.31605385389028 + u[4]* 0.076494241743703 + u[5]* -0.19652125245129 + u[6]* 6.2120166079051 + u[7]* -0.14757603720768 + u[8]* -1.756674274605 + u[9]* -1.9280803867154
        y=y+ -0.03549032657104 * np.cos(fterm) + 0.017672908686963 * np.sin(fterm)
        fterm = u[0]* -0.48235174914102 + u[1]* -0.14505745567104 + u[2]* -0.89285023189899 + u[3]* -0.65796650618568 + u[4]* -1.7818085457027 + u[5]* -0.077077512049044 + u[6]* -3.1546989700182 + u[7]* 0.28593200288056 + u[8]* -1.7965952265115 + u[9]* 0.68987570372033
        y=y+ -0.033383596761382 * np.cos(fterm) + 0.01708951694821 * np.sin(fterm)
        fterm = u[0]* -0.43372466387743 + u[1]* 0.0070073398159157 + u[2]* 0.28432167179528 + u[3]* 0.34117314551252 + u[4]* -0.91625966586057 + u[5]* 0.19353827335367 + u[6]* -0.24508433580305 + u[7]* -0.70501247944371 + u[8]* -1.1859299029664 + u[9]* 0.86604144279862
        y=y+ -0.11207783813209 * np.cos(fterm) + -0.066353923098077 * np.sin(fterm)
        fterm = u[0]* 1.0530682027985 + u[1]* 0.28636638293607 + u[2]* 0.57150450833751 + u[3]* -0.11144645862663 + u[4]* -3.0725638863648 + u[5]* -0.17342818569404 + u[6]* 1.0228359792419 + u[7]* -0.92256310608875 + u[8]* 2.2013540385711 + u[9]* 1.2926329931788
        y=y+ -0.030808166862244 * np.cos(fterm) + 0.038739528019412 * np.sin(fterm)
        fterm = u[0]* 0.21742569239359 + u[1]* -0.30008192867895 + u[2]* 0.0090961284191189 + u[3]* 0.59998484535416 + u[4]* -6.836350335213 + u[5]* -0.24115220856752 + u[6]* -4.492997778579 + u[7]* -0.095675525034475 + u[8]* 0.76763340402437 + u[9]* -0.39440568040737
        y=y+ -0.0060646128345046 * np.cos(fterm) + 0.0020001498578622 * np.sin(fterm)
        fterm = u[0]* 0.33592101311812 + u[1]* 0.29300517495018 + u[2]* -0.081008193206153 + u[3]* 0.65788763344974 + u[4]* 0.49443884363231 + u[5]* -0.14546781842356 + u[6]* 2.6823414085615 + u[7]* 0.1016495953276 + u[8]* 0.71731959720856 + u[9]* 0.49214444361749
        y=y+ 0.049365601607823 * np.cos(fterm) + -0.11114151241192 * np.sin(fterm)
        fterm = u[0]* -0.12313743363216 + u[1]* 0.054325631391886 + u[2]* 0.44523931940928 + u[3]* -0.29965463301554 + u[4]* -6.5319333906529 + u[5]* 0.10456259009935 + u[6]* 6.4734343584366 + u[7]* -0.26451209770456 + u[8]* -0.032280273582581 + u[9]* 0.10726501135496
        y=y+ -0.18747373692342 * np.cos(fterm) + 0.13584975865301 * np.sin(fterm)
        fterm = u[0]* 0.4006160658585 + u[1]* -0.21283083202285 + u[2]* -0.068312192457003 + u[3]* 0.20618038289807 + u[4]* -2.4511429858129 + u[5]* -0.052334463687479 + u[6]* 2.1087287187327 + u[7]* -0.29875820186742 + u[8]* -0.80743257379728 + u[9]* -0.66277883318956
        y=y+ 0.10927821611682 * np.cos(fterm) + -0.16980173269916 * np.sin(fterm)
        fterm = u[0]* 0.27701655987021 + u[1]* -0.18859547586744 + u[2]* 0.58822055078665 + u[3]* -0.169705037502 + u[4]* -5.2430251385084 + u[5]* -0.014934294393431 + u[6]* 4.9214388242382 + u[7]* -1.0679270513252 + u[8]* -0.82405027514928 + u[9]* 0.48310683714814
        y=y+ 0.036114118023937 * np.cos(fterm) + 0.02177097381349 * np.sin(fterm)
        fterm = u[0]* 0.76812303505839 + u[1]* -0.21549786958375 + u[2]* -0.56064503290645 + u[3]* 0.41941568588048 + u[4]* -4.3821816595169 + u[5]* -0.28204286471956 + u[6]* 0.95775292601595 + u[7]* 0.27313504970283 + u[8]* -0.60848484526538 + u[9]* -1.019094971232
        y=y+ 0.022156600266183 * np.cos(fterm) + -0.071298248083971 * np.sin(fterm)
        fterm = u[0]* 0.98327764735988 + u[1]* 0.076033702180366 + u[2]* -0.15793453359845 + u[3]* 0.71950716503931 + u[4]* -0.47354412535569 + u[5]* 0.24127484360951 + u[6]* 0.7659084120113 + u[7]* 0.83200048015893 + u[8]* -0.26268813906648 + u[9]* -1.2054529288702
        y=y+ -0.064087023224232 * np.cos(fterm) + 0.079679907842945 * np.sin(fterm)
        fterm = u[0]* 0.8916980909554 + u[1]* 0.076720953877967 + u[2]* -0.45019093325921 + u[3]* 0.36548965680332 + u[4]* 0.21068731421127 + u[5]* 0.44490303586371 + u[6]* 0.56120813986296 + u[7]* -0.011496002719082 + u[8]* -1.0078130376216 + u[9]* 0.44490598310089
        y=y+ -0.15284350315258 * np.cos(fterm) + -0.070732848135661 * np.sin(fterm)
        fterm = u[0]* -0.29091377550497 + u[1]* -0.32912199707093 + u[2]* -0.4298165020062 + u[3]* 0.59574409894471 + u[4]* -2.8754419446166 + u[5]* -0.086683256116449 + u[6]* 1.6454379877669 + u[7]* 0.25938854556758 + u[8]* -0.97475354208878 + u[9]* 0.10806979810943
        y=y+ -0.24232239333697 * np.cos(fterm) + -0.081581950149644 * np.sin(fterm)
        fterm = u[0]* 0.17893792251594 + u[1]* 0.16954010216603 + u[2]* 0.51201140789787 + u[3]* -1.0523064897854 + u[4]* -1.167040024119 + u[5]* -0.10698900931449 + u[6]* 1.626316962915 + u[7]* -0.0072453457587813 + u[8]* -0.0092316317016417 + u[9]* -0.011162384381199
        y=y+ -0.29386565010948 * np.cos(fterm) + 0.65135209764835 * np.sin(fterm)
        fterm = u[0]* 0.0063606034904218 + u[1]* 0.071501324376628 + u[2]* -0.48863571434896 + u[3]* 0.14135732422574 + u[4]* -3.4840052050416 + u[5]* 0.24675318111587 + u[6]* -1.6449484288109 + u[7]* -0.56672822756487 + u[8]* -1.1501495313197 + u[9]* -0.86455150613677
        y=y+ 0.055390731056039 * np.cos(fterm) + 0.04739767721103 * np.sin(fterm)
        fterm = u[0]* 1.0269981893507 + u[1]* -0.082951886079255 + u[2]* 0.22708479699296 + u[3]* -0.42111959856584 + u[4]* 0.27806038339095 + u[5]* -0.11855285965653 + u[6]* -0.80495473348493 + u[7]* 1.1492815648505 + u[8]* 0.15774188423831 + u[9]* -0.28823932935373
        y=y+ -0.42557167422989 * np.cos(fterm) + 0.13885157000596 * np.sin(fterm)
        fterm = u[0]* 0.39965111097893 + u[1]* 0.13710749855091 + u[2]* 0.26849312382293 + u[3]* 0.81666717467468 + u[4]* 2.4997475602785 + u[5]* 0.25828347457931 + u[6]* 5.392425989108 + u[7]* 0.3779202358358 + u[8]* -1.3746223919269 + u[9]* 1.2911730603403
        y=y+ 0.025005799753262 * np.cos(fterm) + 0.02534531537369 * np.sin(fterm)
        fterm = u[0]* 0.75270340663039 + u[1]* 0.2712441950529 + u[2]* -0.051316020031209 + u[3]* 0.81218286537538 + u[4]* 0.33584399773702 + u[5]* -0.073024756911837 + u[6]* -0.078118634689732 + u[7]* -1.044296955018 + u[8]* -0.78289236871129 + u[9]* 1.2210752978127
        y=y+ 0.0032374278105146 * np.cos(fterm) + 0.068392460514006 * np.sin(fterm)
        y = y * 5.1489801806121 + 14.886169231027
        return y

    def _interpolate_time_series(self, x: np.ndarray):
        r"""
        :param x: 7D (n[t], n[t-1], n[t-2], n[t-3], v[t], v[t-1], v[t-3]) if self.reduce_dimension==False
            else 4D (n[t], n[t-3], v[t], v[t-3])
        """
        assert x.ndim == 1
        if not self.reduce_dimension:
            assert len(x) == 7
            return x
        else:
            assert len(x) == 4
            """
            n, n3, v, v3 = x
            n1 = (2*n + n3)/3
            n2 = (n + 2*n3)/3
            v1 = (2*v + v3)/3
            """
            dn_raw, n3, dv_raw, v3 = x
            # dn, dv \in [0, 1]
            # need to map to [-max_step/2, max_step/2]
            max_step = _MAX_STEP
            dn = (dn_raw - 0.5)*max_step
            dv = (dv_raw - 0.5)*max_step
            n2 = n3 + dn
            n1 = n2 + dn
            n = n1 + dn
            v1 = v3 + 2*dv
            v = v1 + dv
            return np.array([n, n1, n2, n3, v, v1, v3])

    def _get_single_trajectory(self, max_step: int, a=None, box_width=None):
        """
        :param max_step: maximum step size for the fluid system, a ratio between 0 and 1
        :param a: lower bound of the box, float or 7D, if None, will use the default bounds
        :param box_width: width of the box, float or 7D, if None, will use the default bounds
        :return: 7D (n[t], n[t-1], n[t-2], n[t-3], v[t], v[t-1], v[t-3])
        """
        assert not self.reduce_dimension, "Trajectories are not supported for reduced dimension oracle"
        assert 0 < max_step <= 1, f'max_step should be in (0, 1], got {max_step}'
        a, b = self.get_box_bounds()

        if a is None or box_width is None:
            aa = np.array([a]*7)
            bb = np.array([b]*7)
        else:
            aa = np.array(check1Dlist(a, 7))
            bw = np.array(check1Dlist(box_width, 7))
            bb = aa + bw

            assert np.all(aa <= b)
            assert np.all(bb >= a)
            assert np.any(aa < b)
            assert np.any(bb > a)

            aa[aa < a] = a
            bb[bb > b] = b
        
        step = (b - a) * max_step

        n0 = np.random.uniform(low=aa[3], high=bb[3])
        n1 = np.random.uniform(low=max(aa[2], n0 - step), high=min(bb[2], n0 + step))
        n2 = np.random.uniform(low=max(aa[1], n1 - step), high=min(bb[1], n1 + step))
        n3 = np.random.uniform(low=max(aa[0], n2 - step), high=min(bb[0], n2 + step))
        v0 = np.random.uniform(low=aa[6], high=bb[6])
        v2 = np.random.uniform(low=max(aa[5], v0 - 2*step), high=min(bb[5], v0 + 2*step))
        v3 = np.random.uniform(low=max(aa[4], v2 - step), high=min(bb[4], v2 + step))
        return np.array([n3, n2, n1, n0, v3, v2, v0])

    def get_trajectory(self, num_trajectories: int=1, a=None, box_width=None):
        """
        :param num_trajectories: number of trajectories to generate
        :param a: lower bound of the box, float or 7D, if None, will use the default bounds
        :param box_width: width of the box, float or 7D, if None, will use the default bounds
        :return: (num_trajectories, 7) array of trajectories
        """
        trajectories = []
        for _ in range(num_trajectories):
            x = self._get_single_trajectory(_MAX_STEP, a=a, box_width=box_width)
            trajectories.append(x.reshape(1, -1))
        X = np.vstack(trajectories)
        return X

    def query(self,x:np.ndarray, noisy=True):
        function_value = self.f(x)
        if noisy:
            epsilon = np.random.normal(0,self.observation_noise,1)[0]
            function_value += epsilon
        return function_value

    def get_random_data(self, n, noisy = True):
        """
        Generates random n uniform random queries inside the box bounds of the oracle and return the queries and oracle values

        Arguments:
            n : int - number of uniform random queries
            noisy : bool - flag if noise should be added - should raise Error if noisy=False is not possible if e.g. real world oracle without ground truth
        Returns:
            np.array - input/queries with dimension (n,d) where d is the input dimension
            np.array - oracle values at input dimension = (n,1)
        """
        if self.trajectory_sampler:
            X = self.get_trajectory(n)
            Y = self.batch_query(X, noisy=noisy).reshape(-1, 1)
            return X, Y
        else:
            return super().get_random_data(n, noisy)

    def get_random_data_in_box(self, n: int, a, box_width, noisy: bool = True):
        r"""
        Generates random n uniform random queries inside the specified box bounds and return the queries and oracle values

        Arguments:
            n : int - number of uniform random queries
            a: float or 7D of floats - lower bound(s) of the specified box
            box_width: float or 7D of floats - box width(s) of the specified box, so the box will be from a to a+box_width
            noisy : bool - flag if noise should be added - should raise Error if noisy=False is not possible if e.g. real world oracle without ground truth
        Returns:
            np.array - input/queries with dimension (n,d) where d is the input dimension
            np.array - oracle values at input dimension = (n,1)
        """
        if self.trajectory_sampler:
            X = self.get_trajectory(n, a=a, box_width=box_width)
            Y = self.batch_query(X, noisy=noisy).reshape(-1, 1)
            return X, Y
        else:
            return super().get_random_data_in_box(n, a, box_width, noisy)

class HighPressureFluidSystem(StandardConstrainedOracle):
    def __init__(
        self,
        observation_noise: Union[float, List[float]],
        normalized: bool=True,
        trajectory_sampler: bool=True,
    ):
        """
        :param observation_noise: standard deviation of the observation noise (Gaussian noise)
            specify all functions by passing a float or specify each individually by passing a list of 2 floats
        :param normalized: whether to normalize the function values and the constraint values
        :param trajectory_sampler: whether to use the trajectory sampler or not
        """
        if hasattr(observation_noise, '__len__'):
            if len(observation_noise) == 1:
                observation_noise = [observation_noise[0]] * 2
            elif len(observation_noise) == 2:
                pass
            else:
                assert False, f'passing incorrect number of observation_noise to {self.__class__.__name__}.__init__ method'
        else:
            observation_noise = [observation_noise] * 2

        main = HighPressureFluidSystemMain(observation_noise[0], reduce_dimension=False, trajectory_sampler=trajectory_sampler)
        constraint = HighPressureFluidSystemMain(observation_noise[1], reduce_dimension=False, trajectory_sampler=trajectory_sampler)

        self._f_mu = _F_MEAN if normalized else 0
        self._f_std = _F_STD if normalized else 1
        super().__init__(main, constraint)

    @property
    def trajectory_sampler(self):
        return self.oracle.trajectory_sampler

    def get_trajectory(self, num_trajectories: int=1, a=None, box_width=None):
        """
        :param num_trajectories: number of trajectories to generate
        :param a: lower bound of the box, float or 7D, if None, will use the default bounds
        :param box_width: width of the box, float or 7D, if None, will use the default bounds
        :return: (num_trajectories, 7) array of trajectories
        """
        return self.oracle.get_trajectory(num_trajectories, a=a, box_width=box_width)

    def query(self, x, noisy: bool = True):
        f = self.oracle.f(x)
        #q = 1 - np.exp((f - 18)/10)
        f = (f - self._f_mu) / self._f_std
        #q = q / self._q_std
        q = -f
        if noisy:
            epsilon = np.random.normal(0, self.oracle.observation_noise, 1)[0]
            f += epsilon
            epsilon = np.random.normal(0, self.constraint_oracle[0].observation_noise, 1)[0]
            q += epsilon
        return f, q[None]

    def batch_query(self, X, noisy: bool = True):
        Y = []
        Z = []
        for i in range(X.shape[-2]):
            y, z = self.query(X[..., i,:], noisy)
            Y.append(y)
            Z.append(z.reshape(-1, 1))
        return np.array(Y), np.vstack(Z)

    def get_random_data(self, n: int, noisy: bool = True):
        """
        get random data for the oracle and constraint

        :param n: int - the number of points
        :param noisy: bool - whether to add noise or not

        :return: ([N, D] np.ndarray, [N, 1] np.ndarray, [N, n_constraint] np.ndarray) - 
            the random data for the oracle and the constraint
            (X, Y, Z)
        """
        if self.trajectory_sampler:
            X = self.get_trajectory(n)
            Y, Z = self.batch_query(X, noisy=noisy)
            return X, Y.reshape(-1, 1), Z
        else:
            return super().get_random_data(n, noisy)

    def get_random_data_in_box(self, n, a, box_width, noisy = True):
        """
        Generates random n uniform random points in the box [a, a + box_width]

        :param n: int - the number of points
        :param a: float or [D,] array - the lower bound of the box
        :param box_width: float or [D,] array - the width of the box
        :param noisy: bool - whether to add noise or not

        :return: ([N, D] np.ndarray, [N, 1] np.ndarray, [N, n_constraint] np.ndarray) - 
            the random data for the oracle and the constraint
            (X, Y, Z)
        """
        if self.trajectory_sampler:
            X = self.get_trajectory(n, a=a, box_width=box_width)
            Y, Z = self.batch_query(X, noisy=noisy)
            return X, Y.reshape(-1, 1), Z
        else:
            return super().get_random_data_in_box(n, a, box_width, noisy)

class HighPressureFluidSystemReduce(HighPressureFluidSystem):
    def __init__(
        self,
        observation_noise: Union[float, List[float]],
        normalized: bool=True,
    ):
        """
        :param observation_noise: standard deviation of the observation noise (Gaussian noise)
            specify all functions by passing a float or specify each individually by passing a list of 2 floats
        :param normalized: whether to normalize the function values and the constraint values
        """
        if hasattr(observation_noise, '__len__'):
            if len(observation_noise) == 1:
                observation_noise = [observation_noise[0]] * 2
            elif len(observation_noise) == 2:
                pass
            else:
                assert False, f'passing incorrect number of observation_noise to {self.__class__.__name__}.__init__ method'
        else:
            observation_noise = [observation_noise] * 2

        main = HighPressureFluidSystemMain(observation_noise[0], reduce_dimension=True, trajectory_sampler=False)
        constraint = HighPressureFluidSystemMain(observation_noise[1], reduce_dimension=True, trajectory_sampler=False)

        self._f_mu = _F_MEAN if normalized else 0
        self._f_std = _F_STD if normalized else 1
        StandardConstrainedOracle.__init__(self, main, constraint)

class HighPressureFluidSystemReduceGPInterpolated(StandardConstrainedOracle):
    def __init__(self, *args, **kwargs):
        from alef.configs.kernels.pytorch_kernels.elementary_kernels_pytorch_configs import BasicRBFPytorchConfig
        from alef.configs.models.gp_model_pytorch_config import BasicGPModelPytorchConfig
        from alef.models.model_factory import ModelFactory
        _backend = HighPressureFluidSystemReduce(*args, **kwargs)
        D = _backend.get_dimension()
        k_config = BasicRBFPytorchConfig(input_dimension=D)
        m_config = BasicGPModelPytorchConfig(kernel_config=k_config)
        self.y_model = ModelFactory.build(m_config)
        self.z_model = ModelFactory.build(m_config)
        X, Y, Z = _backend.get_random_data(500, noisy=True)
        self.initialize_gp_posterior_function(X, Y, Z)
        super().__init__(_backend.oracle, _backend.constraint_oracle[0])

    def initialize_gp_posterior_function(self, X_prior, Y_prior, Z_prior):
        # training model
        self.y_model.infer(X_prior, Y_prior)
        self.z_model.infer(X_prior, Z_prior)
        # get trained kernel
        y_kernel = self.y_model.kernel_module
        z_kernel = self.z_model.kernel_module
        # get trained observation noise variance
        self._y_var = self.y_model.likelihood.noise.detach()
        self._z_var = self.z_model.likelihood.noise.detach()
        # we need: cholesky of prior gram matrices, prior bayesian linear models
        y_kernel.sample_fourier_features(1000, num_functions=1)
        z_kernel.sample_fourier_features(1000, num_functions=1)
        self._f_blm_module = y_kernel.bayesian_linear_model(x_expanded_already=True)
        self._q_blm_module = z_kernel.bayesian_linear_model(x_expanded_already=True)
        #
        X_torch = torch.from_numpy(X_prior).to(torch.get_default_dtype()).expand((1,1,1) + X_prior.shape)
        Y_torch = torch.from_numpy(Y_prior).to(torch.get_default_dtype()).reshape([1,1,1,-1])
        Z_torch = torch.from_numpy(Z_prior).to(torch.get_default_dtype()).reshape([1,1,1,-1])
        
        Ky = compute_kernel_batch([y_kernel], X_torch, X_torch, self._y_var, batch_dim=1)
        epsilon = torch.normal( 0.0, self._y_var.expand(Y_torch.shape) )
        Ly = torch.linalg.cholesky(Ky)
        Ay = torch.linalg.solve_triangular(
            Ly,
            (Y_torch - self._f_blm_module(X_torch) - epsilon).unsqueeze(-1),
            upper=False
        )
        Kinv_y = torch.linalg.solve_triangular(
            Ly.transpose(-2, -1),
            Ay,
            upper=True
        )
        Kz = compute_kernel_batch([z_kernel], X_torch, X_torch, self._z_var, batch_dim=1)
        epsilon = torch.normal( 0.0, self._z_var.expand(Z_torch.shape) )
        Lz = torch.linalg.cholesky(Kz)
        Az = torch.linalg.solve_triangular(
            Lz,
            (Z_torch - self._q_blm_module(X_torch) - epsilon).unsqueeze(-1),
            upper=False
        )
        Kinv_z = torch.linalg.solve_triangular(
            Lz.transpose(-2, -1),
            Az,
            upper=True
        )
        
        self._prior = {
            'x': X_torch,
            'Kinv_y': Kinv_y,
            'Kinv_z': Kinv_z,
        }

    def query(self, x, noisy: bool = True):
        Y, Z = self.batch_query(np.atleast_2d(x), noisy)
        return Y[0], Z[0]

    def batch_query(self, X, noisy: bool = True):
        x_new_torch = torch.from_numpy(X).to(torch.get_default_dtype()).expand((1,1,1) + X.shape)
        y_kernel = self.y_model.kernel_module
        z_kernel = self.z_model.kernel_module
        # f
        f_new = self._f_blm_module(x_new_torch)
        k_new = compute_kernel_batch([y_kernel], x_new_torch, self._prior['x'], batch_dim=1)
        f = f_new.unsqueeze(-1) + torch.matmul(k_new, self._prior['Kinv_y']) 
        f = f.detach().double().numpy().reshape(-1)
        # q
        q_new = self._q_blm_module(x_new_torch)
        k_new = compute_kernel_batch([z_kernel], x_new_torch, self._prior['x'], batch_dim=1)
        q = q_new.unsqueeze(-1) + torch.matmul(k_new, self._prior['Kinv_z']) 
        q = q.detach().double().numpy().reshape(-1,1)
        return f, q
        


if __name__ == "__main__":
    from matplotlib import pyplot as plt
    oracle = HighPressureFluidSystemReduce(0.01)
    X, Y, Z = oracle.get_random_data(10000, noisy=True)
    print(X.shape)
    print(Y.shape)
    print(Z.shape)
    print( f'[{Y.min()}, {Y.max()}]' )
    print( f'mean {Y.mean()}, std {np.sqrt(Y.var())}' )
    print( f'[{Z.min()}, {Z.max()}]' )
    print( f'mean {Z.mean()}, std {np.sqrt(Z.var())}' )
    print( 100*(Z >= 0).sum() / Z.shape[0], '%' )
    split_factor = 3
    fig, axs = plt.subplots(split_factor, split_factor, sharex='all', sharey='all')
    for x2 in range(split_factor):
        mask2 = np.logical_and(X[:, 2] >= x2/split_factor, X[:, 2] <= (x2+1)/split_factor) # x2 in [0, 1/3] or [1/3, 2/3] or [2/3, 1]
        for x3 in range(split_factor):
            mask3 = np.logical_and(X[:, 3] >= x3/split_factor, X[:, 3] <= (x3+1)/split_factor) # x3 in [0, 1/3] or [1/3, 2/3] or [2/3, 1]
            for x0 in range(split_factor):
                mask0 = np.logical_and(X[:, 0] >= x0/split_factor, X[:, 0] <= (x0+1)/split_factor) # x0 in [0, 1/3] or [1/3, 2/3] or [2/3, 1]
                for x1 in range(split_factor):
                    mask1 = np.logical_and(X[:, 1] >= x1/split_factor, X[:, 1] <= (x1+1)/split_factor) # x1 in [0, 1/3] or [1/3, 2/3] or [2/3, 1]
                    mask = np.logical_and(np.logical_and(mask2, mask3), np.logical_and(mask0, mask1))
                    safe_ratio = np.sum(Z[mask] >= 0)
                    axs[x3, x2].text(
                        (x0+0.5)/split_factor,
                        (x1+0.5)/split_factor,
                        f'{safe_ratio}/{mask.sum()}',
                        ha="center", va="center", color="k"
                    )
            for x0 in range(1, split_factor):
                axs[x3, x2].plot([x0/split_factor, x0/split_factor], [0, 1], 'k--')
            for x1 in range(1, split_factor):
                axs[x3, x2].plot([0, 1], [x1/split_factor, x1/split_factor], 'k--')
            axs[x3, x2].set_title(f'x2 (dv): [{x2/split_factor:.2f}, {(x2+1)/split_factor:.2f}]\nx3 (v): [{x3/split_factor:.2f}, {(x3+1)/split_factor:.2f}]')
            axs[x3, x2].set_xlabel('x0 (dn)')
            axs[x3, x2].set_ylabel('x1 (n)')
    plt.tight_layout()
    plt.show()


    X, Y, Z = oracle.get_random_data_in_box(5000, 0.4, 0.2, noisy=True)
    print(X.shape)
    print(Y.shape)
    print(Z.shape)
    print( f'[{Y.min()}, {Y.max()}]' )
    print( f'mean {Y.mean()}, std {np.sqrt(Y.var())}' )
    print( f'[{Z.min()}, {Z.max()}]' )
    print( f'mean {Z.mean()}, std {np.sqrt(Z.var())}' )
    print( 100*(Z >= 0).sum() / Z.shape[0], '%' )
